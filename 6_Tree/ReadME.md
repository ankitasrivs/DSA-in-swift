{"canmore.create_textdoc":{"name":"tree-dsa-theory","type":"document","content":"# ðŸŒ³ Tree Data Structure in Swift\n\nThis document covers the theory of trees in Data Structures and Algorithms (DSA), along with Swift code examples.\n\n---\n\n## ðŸ“– What is a Tree?\n- A tree is a hierarchical data structure consisting of nodes.\n- The top node is called the root.\n- Each node may have 0 or more children.\n- A tree with no nodes is called an empty tree.\n\n### Properties of a Tree:\n1. A tree with n nodes has exactly n-1 edges.\n2. There is exactly one path between the root and any node.\n3. Trees are acyclic graphs.\n\n---\n\n## ðŸ“Œ Important Terminologies\n- Root â†’ The top-most node.\n- Parent â†’ A node that has children.\n- Child â†’ A node descended from another node.\n- Leaf â†’ A node with no children.\n- Height â†’ Longest path from root to a leaf.\n- Depth â†’ Distance of a node from the root.\n\n---\n\n## ðŸŒ³ Types of Trees\n1. Binary Tree â†’ Each node has at most 2 children (left & right).\n2. Binary Search Tree (BST) â†’ Left child < Parent < Right child.\n3. Balanced Trees â†’ AVL, Red-Black trees, etc.\n4. N-ary Tree â†’ A node can have n children.\n\n---\n\n## ðŸ” Tree Traversals\n\nTraversal = visiting all nodes in a tree in a specific order.\n\n### 1. DFS (Depth-First Search)\nDFS explores as deep as possible before backtracking.\n\nTypes:\n- Preorder (Root â†’ Left â†’ Right)\n- Inorder (Left â†’ Root â†’ Right)\n- Postorder (Left â†’ Right â†’ Root)\n\nâœ… All three are DFS traversals.\n\n### 2. BFS (Breadth-First Search)\nBFS explores nodes level by level (top to bottom, left to right).\n\n- Also called Level Order Traversal.\n- Uses a Queue instead of recursion.\n\n---\n\n## âš¡ Swift Implementation\n\n### Tree Node Definition\nswift\nclass TreeNode {\n var val: Int\n var left: TreeNode?\n var right: TreeNode?\n\n init(_ val: Int) {\n self.val = val\n self.left = nil\n self.right = nil\n }\n}\n\n\n---\n\n### DFS Traversals (Recursive)\nswift\nfunc preorder(_ root: TreeNode?) {\n guard let root = root else { return }\n print(root.val, terminator: \" \")\n preorder(root.left)\n preorder(root.right)\n}\n\nfunc inorder(_ root: TreeNode?) {\n guard let root = root else { return }\n inorder(root.left)\n print(root.val, terminator: \" \")\n inorder(root.right)\n}\n\nfunc postorder(_ root: TreeNode?) {\n guard let root = root else { return }\n postorder(root.left)\n postorder(root.right)\n print(root.val, terminator: \" \")\n}\n\n\n---\n\n### BFS Traversal (Level Order)\nswift\nfunc levelOrder(_ root: TreeNode?) {\n guard let root = root else { return }\n var queue: [TreeNode] = [root]\n\n while !queue.isEmpty {\n let node = queue.removeFirst()\n print(node.val, terminator: \" \")\n\n if let left = node.left {\n queue.append(left)\n }\n if let right = node.right {\n queue.append(right)\n }\n }\n}\n\n\n---\n\n## ðŸ“ Example Usage\nswift\nlet root = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.left?.left = TreeNode(4)\nroot.left?.right = TreeNode(5)\n\nprint(\"Preorder (DFS):\", terminator: \" \")\npreorder(root) // 1 2 4 5 3\n\nprint(\"\\nInorder (DFS):\", terminator: \" \")\ninorder(root) // 4 2 5 1 3\n\nprint(\"\\nPostorder (DFS):\", terminator: \" \")\npostorder(root) // 4 5 2 3 1\n\nprint(\"\\nLevel Order (BFS):\", terminator: \" \")\nlevelOrder(root) // 1 2 3 4 5\n\n\n---\n\n## ðŸŽ¯ Key Takeaways\n- DFS â†’ Goes deep first (Preorder, Inorder, Postorder).\n- BFS â†’ Goes level by level (Level Order).\n- DFS is usually recursive/stack-based, BFS is queue-based.\n- Both traversals are fundamental for solving tree problems in DSA.\n\n---\n\nðŸš€ Next step: Practice problems like finding tree height, checking if balanced, lowest common ancestor, etc."}}
