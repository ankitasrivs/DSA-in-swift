/*

The main reason:
ðŸ‘‰ To avoid checking j != pivotIndex inside the loop.

If you keep the pivot in place (say at index low), you'd have to carefully skip over it in your loop or handle comparisons conditionally, which complicates the code.
*/


func quickSortWhenLeftPivot(_ arr:  inout [Int], _ low: Int, _ high: Int) {
    if low < high {
        print(" before partition is  array is : \(arr)")
        let partition = partition(&arr, low, high)
        print("partition is :\(partition) and array is : \(arr)")
        quickSortWhenLeftPivot(&arr, low, partition - 1)
        quickSortWhenLeftPivot(&arr, partition + 1, high)
    }

}


func partitionWhenLeftPivot(_ arr:  inout [Int], _ low: Int, _ high: Int) -> Int {
    arr.swapAt(low, high)
    print(arr)
    let pivot = arr[high]
    var i = low
    for j in low..<high {
        if arr[j] < pivot {
            print("array before sorting: \(arr)")
            arr.swapAt(i, j)
            print("array after sorting: \(arr)")
            i += 1
        }
    }
    print("high and i swap before: \(arr)")
    arr.swapAt(i, high)
    print("high and i swap after: \(arr)")
    return i
}

var arr = [4, 2, 7, 1]
quickSortWhenLeftPivot(&arr,0, arr.count - 1)
print("Sorted array: \(arr)")


/*

WHEN CENTER IS PIVOT

*/


func quickSortWhenCenterPivot(_ arr:  inout [Int], _ low: Int, _ high: Int) {
    if low < high {
        print(" before partition is  array is : \(arr)")
        let partition = partitionWhenCenterPivot(&arr, low, high)
        print("partition is :\(partition) and array is : \(arr)")
        quickSortWhenCenterPivot(&arr, low, partition - 1)
        quickSortWhenCenterPivot(&arr, partition + 1, high)
    }

}


func partitionWhenCenterPivot(_ arr:  inout [Int], _ low: Int, _ high: Int) -> Int {
    let mid = (low + high) / 2
    arr.swapAt(mid, high)
    print(arr)
    let pivot = arr[high]
    var i = low
    for j in low..<high {
        if arr[j] < pivot {
            print("array before sorting: \(arr)")
            arr.swapAt(i, j)
            print("array after sorting: \(arr)")
            i += 1
        }
    }
    print("high and i swap before: \(arr)")
    arr.swapAt(i, high)
    print("high and i swap after: \(arr)")
    return i
}

var arr = [4, 2, 7, 1]
quickSortWhenCenterPivot(&arr,0, arr.count - 1)
print("Sorted array: \(arr)")


/*

WHEN LAST IS PIVOT
*/


func quickSortWhenLastPivot(_ arr:  inout [Int], _ low: Int, _ high: Int) {
    if low < high {
        print(" before partition is  array is : \(arr)")
        let partition = partitionWhenLastPivot(&arr, low, high)
        print("partition is :\(partition) and array is : \(arr)")
        quickSortWhenLastPivot(&arr, low, partition - 1)
        quickSortWhenLastPivot(&arr, partition + 1, high)
    }

}


func partitionWhenLastPivot(_ arr:  inout [Int], _ low: Int, _ high: Int) -> Int {

    print(arr)
    let pivot = arr[high]
    var i = low
    for j in low..<high {
        if arr[j] < pivot {
            print("array before sorting: \(arr)")
            arr.swapAt(i, j)
            print("array after sorting: \(arr)")
            i += 1
        }
    }
    print("high and i swap before: \(arr)")
    arr.swapAt(i, high)
    print("high and i swap after: \(arr)")
    return i
}

var arr = [4, 2, 7, 1]
quickSortWhenLastPivot(&arr,0, arr.count - 1)
print("Sorted array: \(arr)")


/*
Great question! Choosing the **pivot position** in QuickSort significantly impacts performance, especially for **unbalanced input arrays**.

Letâ€™s break it down:

---

## ðŸ”¢ 1. **Last Element as Pivot**

### âœ… Pros:

* Easy to implement.
* Works well if array is randomly shuffled.

### âŒ Cons:

* **Very bad for already sorted or reverse-sorted arrays**, where every partition is maximally unbalanced (O(nÂ²)).

---

## ðŸ”¢ 2. **First Element as Pivot**

### âœ… Pros:

* Also simple to implement.
* Works okay on shuffled input.

### âŒ Cons:

* **Same flaw as last element** â€” already sorted/reverse sorted data leads to worst-case behavior (O(nÂ²)).

---

## ðŸ”¢ 3. **Middle (Center) Element as Pivot**

### âœ… Pros:

* Slightly better than first/last for partially sorted data.
* Avoids worst-case in some skewed cases.

### âŒ Cons:

* Still deterministic â€” a clever adversary can craft input to break it (in theory).

---

## ðŸ§  Best (in practice): **Random or Median-of-Three**

### âœ… 4. **Random Pivot**

* Randomly choose a pivot in `[low...high]`.
* Gives excellent **average-case performance** (expected O(n log n)).
* Immune to sorted/reversed input.

### âœ… 5. **Median-of-Three Pivot**

* Take the **median of first, middle, and last** elements.
* Good balance in many real-world scenarios.
* Helps avoid worst-case behavior for nearly sorted input.

```swift
let mid = (low + high) / 2
let pivotIndex = medianIndex(arr, low, mid, high)
```

---

## ðŸ”š Final Comparison

| Pivot Type          | Time Complexity (Worst) | Good for Random? | Good for Sorted? | Practical Use?          |
| ------------------- | ----------------------- | ---------------- | ---------------- | ----------------------- |
| First               | O(nÂ²)                   | âœ…                | âŒ                | ðŸ‘Ž Simple only          |
| Last                | O(nÂ²)                   | âœ…                | âŒ                | ðŸ‘Ž Simple only          |
| Center              | O(nÂ²)                   | âœ…                | âŒ                | ðŸ‘ Slightly better      |
| **Random**          | O(n log n) expected     | âœ…                | âœ…                | âœ…âœ… Best for general use |
| **Median-of-Three** | O(n log n) average      | âœ…âœ…               | âœ…âœ…               | âœ…âœ… Fast and robust      |

---

## âœ… Verdict

> ðŸ”¥ Use **random pivot** or **median-of-three** in production.
> ðŸ§ª Use **first/last/center** for **educational or controlled environments** only.

Let me know if you want to implement median-of-three in your Swift quicksort!

*/
